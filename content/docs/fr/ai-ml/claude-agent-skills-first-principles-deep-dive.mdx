---
title: "Claude Agent Skills : Analyse approfondie selon les premiers principes"
description: "Analyse technique approfondie du syst√®me Agent Skills de Claude selon les premiers principes, examinant l'architecture m√©ta-outil, l'injection de contexte bas√©e sur les prompts, et le cycle de vie complet d'ex√©cution avec des √©tudes de cas r√©els."
image: /images/docs/claude-agent-skills-first-principles-deep-dive/agent-skills-architecture.svg
lang: fr
category: ai-ml
difficulty: advanced
tags:
  - claude-skills
  - claude-code
  - ai-agents
  - prompt-engineering
  - meta-tools
  - llm-architecture
  - skill-development
source_url: "https://leehanchung.github.io/blogs/2025/10/26/claude-skills-deep-dive/"
published_date: "2025-10-26"
author: "Hanchung Lee"

source:
  url: "https://leehanchung.github.io/blogs/2025/10/26/claude-skills-deep-dive/"
  name: "Hanchung Lee's Blog"
  author: "Hanchung Lee"
  published_date: "2025-10-26"
  accessed_date: "2025-11-24"
  license: "Copyright ¬© 2025 Hanchung Lee"

import:
  date: "2025-11-24"
  slug: "claude-agent-skills-first-principles-deep-dive"
  translator: "Claude AI"
---

import { SourceAttribution } from '@/components/SourceAttribution';

<SourceAttribution
  source={{
    url: "https://leehanchung.github.io/blogs/2025/10/26/claude-skills-deep-dive/",
    name: "Hanchung Lee's Blog",
    author: "Hanchung Lee",
    publishedDate: "2025-10-26",
    accessedDate: "2025-11-24",
    license: "Copyright ¬© 2025 Hanchung Lee"
  }}
  languages={['en', 'zh', 'fr']}
  currentLang="fr"
/>

# Claude Agent Skills : Analyse approfondie selon les premiers principes

Le syst√®me Agent `Skills` de Claude repr√©sente une architecture m√©ta-outil sophistiqu√©e bas√©e sur les prompts qui √©tend les capacit√©s LLM gr√¢ce √† l'injection d'instructions sp√©cialis√©es. Contrairement aux appels de fonctions traditionnels ou √† l'ex√©cution de code, les `skills` fonctionnent par **expansion de prompt** et **modification de contexte** pour modifier la fa√ßon dont Claude traite les demandes suivantes sans √©crire de code ex√©cutable.

Cette analyse approfondie d√©construit le syst√®me Agent `Skills` de Claude selon les premiers principes, documente l'architecture o√π un outil nomm√© "`Skill`" agit comme m√©ta-outil pour injecter des prompts sp√©cifiques au domaine dans le contexte de conversation. Nous parcourrons le cycle de vie complet en utilisant `skill-creator` et `internal-comms` comme √©tudes de cas, en examinant tout, de l'analyse de fichiers √† la structure de requ√™te API jusqu'au processus de d√©cision de Claude.

## Vue d'ensemble des Claude Agent Skills

Claude utilise les `Skills` pour am√©liorer sa performance dans des t√¢ches sp√©cifiques. Les `Skills` sont d√©finis comme des dossiers incluant des instructions, des scripts et des ressources que Claude peut charger au besoin. Claude utilise un **syst√®me d√©claratif bas√© sur les prompts** pour la d√©couverte et l'invocation de skills. Le mod√®le IA (Claude) prend la d√©cision d'invoquer les `skills` en fonction des descriptions textuelles pr√©sent√©es dans son prompt syst√®me. **Il n'y a pas de s√©lection algorithmique de `skill` ou de d√©tection d'intention aliment√©e par l'IA** au niveau du code. La prise de d√©cision se produit enti√®rement dans le processus de raisonnement de Claude en fonction des descriptions de skills fournies.

Les `Skills` ne sont pas du code ex√©cutable. Ils **NE** lancent **PAS** Python ou JavaScript, et il n'y a pas de serveur HTTP ou d'appel de fonction en arri√®re-plan. Ils ne sont pas non plus cod√©s en dur dans le prompt syst√®me de Claude. Les `Skills` vivent dans une partie s√©par√©e de la structure de requ√™te API.

Alors qu'est-ce que c'est ? Les `Skills` sont des mod√®les de prompt sp√©cialis√©s qui injectent des instructions sp√©cifiques au domaine dans le contexte de conversation. Lorsqu'un skill est invoqu√©, il modifie √† la fois le contexte de conversation (en injectant des prompts d'instruction) et le contexte d'ex√©cution (en modifiant les permissions d'outils et potentiellement en changeant de mod√®le). Au lieu d'ex√©cuter des actions directement, les skills se d√©veloppent en prompts d√©taill√©s qui pr√©parent Claude √† r√©soudre un type sp√©cifique de probl√®me. Chaque skill appara√Æt comme un ajout dynamique au sch√©ma d'outils que Claude voit.

Lorsque les utilisateurs envoient une requ√™te, Claude re√ßoit trois choses : le message utilisateur, les outils disponibles (Read, Write, Bash, etc.) et l'outil `Skill`. La description de l'outil `Skill` contient une liste format√©e de chaque skill disponible avec leur `name`, `description` et d'autres champs combin√©s. Claude lit cette liste et utilise sa compr√©hension native du langage pour faire correspondre votre intention avec les descriptions de skills. Si vous dites "aidez-moi √† cr√©er un skill pour les logs", Claude voit la description du skill `internal-comms` ("Lorsque l'utilisateur veut √©crire des communications internes en utilisant le format que son entreprise aime utiliser"), reconna√Æt la correspondance et invoque l'outil `Skill` avec `command: "internal-comms"`.

> **Note terminologique :**
>
> *   **Outil `Skill`** (S majuscule) = Le m√©ta-outil qui g√®re tous les skills. Il appara√Æt dans le tableau `tools` de Claude aux c√¥t√©s de Read, Write, Bash, etc.
> *   **skills** (s minuscule) = Skills individuels comme `pdf`, `skill-creator`, `internal-comms`. Ce sont les mod√®les d'instructions sp√©cialis√©s que l'outil `Skill` charge.

Voici une repr√©sentation plus visuelle de la fa√ßon dont les `skills` sont utilis√©s par Claude.

![Claude Skill Flowchart](https://leehanchung.github.io/assets/img/2025-10-26/01-claude-skill-1.png)

Le m√©canisme de s√©lection de skills n'a pas de routage algorithmique ou de classification d'intention au niveau du code. Claude Code n'utilise pas d'embeddings, de classificateurs ou de correspondance de motifs pour d√©cider quel skill invoquer. Au lieu de cela, le syst√®me formate tous les skills disponibles en une description textuelle int√©gr√©e dans le prompt de l'outil `Skill`, et laisse le mod√®le de langage de Claude prendre la d√©cision. C'est du raisonnement LLM pur. Pas de regex, pas de correspondance de mots-cl√©s, pas de d√©tection d'intention bas√©e sur le ML. La d√©cision se produit √† l'int√©rieur du passage avant de Claude √† travers le transformer, pas dans le code de l'application.

Lorsque Claude invoque un skill, le syst√®me suit un flux de travail simple : il charge un fichier markdown (`SKILL.md`), l'√©tend en instructions d√©taill√©es, injecte ces instructions comme nouveaux messages utilisateur dans le contexte de conversation, modifie le contexte d'ex√©cution (outils autoris√©s, s√©lection de mod√®le) et continue la conversation dans cet environnement enrichi. C'est fondamentalement diff√©rent des outils traditionnels, qui s'ex√©cutent et retournent des r√©sultats. Les skills _pr√©parent Claude_ √† r√©soudre un probl√®me, plut√¥t que de le r√©soudre directement.

Le tableau suivant aide √† mieux distinguer la diff√©rence entre les outils et les Skills et leurs capacit√©s :

| Aspect | Outils traditionnels | Skills |
| --- | --- | --- |
| **Mod√®le d'ex√©cution** | Synchrone, direct | Expansion de prompt |
| **Objectif** | Effectuer des op√©rations sp√©cifiques | Guider des flux de travail complexes |
| **Valeur de retour** | R√©sultats imm√©diats | Contexte de conversation + changements de contexte d'ex√©cution |
| **Exemple** | `Read`, `Write`, `Bash` | `internal-comms`, `skill-creator` |
| **Concurrence** | G√©n√©ralement s√ªr | Non s√ªr pour la concurrence |
| **Type** | Divers | Toujours `"prompt"` |

## Construction d'Agent Skills

Plongeons maintenant dans la construction de Skills en examinant le Skill `skill-creator` du d√©p√¥t de skills d'Anthropic comme √©tude de cas. Pour rappel, les `skills` d'agent sont des dossiers organis√©s d'instructions, de scripts et de ressources que les agents peuvent d√©couvrir et charger dynamiquement pour mieux performer dans des t√¢ches sp√©cifiques. Les `Skills` √©tendent les capacit√©s de Claude en emballant votre expertise dans des ressources composables pour Claude, transformant les agents polyvalents en agents sp√©cialis√©s qui correspondent √† vos besoins.

> **Insight cl√© :** Skill = Mod√®le de prompt + Injection de contexte de conversation + Modification de contexte d'ex√©cution + Fichiers de donn√©es et scripts Python optionnels

Chaque `Skill` est d√©fini dans un fichier markdown nomm√© `SKILL.md` (insensible √† la casse) avec des fichiers group√©s optionnels stock√©s sous `/scripts`, `/references` et `/assets`. Ces fichiers group√©s peuvent √™tre des scripts Python, des scripts shell, des d√©finitions de polices, des mod√®les, etc. En utilisant `skill-creator` comme exemple, il contient `SKILL.md`, `LICENSE.txt` pour la licence, et quelques scripts Python sous le dossier `/scripts`. `skill-creator` n'a ni `/references` ni `/assets`.

![skill-creator package](https://leehanchung.github.io/assets/img/2025-10-26/03-claude-skill-package.png)

Les skills sont d√©couverts et charg√©s depuis plusieurs sources. Claude Code scanne les param√®tres utilisateur (`~/.config/claude/skills/`), les param√®tres de projet (`.claude/skills/`), les skills fournis par les plugins et les skills int√©gr√©s pour construire la liste des skills disponibles. Pour Claude Desktop, nous pouvons t√©l√©charger un skill personnalis√© comme suit.

![Claude Desktop Skill](https://leehanchung.github.io/assets/img/2025-10-26/02-claude-desktop-skill.png)

> **REMARQUE :** Le concept le plus important pour construire des Skills est la **Divulgation progressive** - montrer juste assez d'informations pour aider les agents √† d√©cider quoi faire ensuite, puis r√©v√©ler plus de d√©tails au fur et √† mesure qu'ils en ont besoin. Dans le cas des `agent skills`, cela
>
> 1.   Divulgue le Frontmatter : minimal (nom, description, licence)
> 2.   Si un `skill` est choisi, charge SKILL.md : complet mais cibl√©
> 3.   Puis charge les ressources d'aide, les r√©f√©rences et les scripts au fur et √† mesure que le `skill` est ex√©cut√©

## √âcrire SKILL.md

`SKILL.md` est le c≈ìur du prompt d'un skill. C'est un fichier markdown qui suit une structure en deux parties - frontmatter et contenu. Le frontmatter configure COMMENT le skill s'ex√©cute (permissions, mod√®le, m√©tadonn√©es), tandis que le contenu markdown indique √† Claude QUOI faire. Le frontmatter est l'en-t√™te du fichier markdown √©crit en YAML.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 1. YAML Frontmatter (Metadata)      ‚îÇ ‚Üê Configuration
‚îÇ    ---                              ‚îÇ
‚îÇ    name: skill-name                 ‚îÇ
‚îÇ    description: Brief overview      ‚îÇ
‚îÇ    allowed-tools: "Bash, Read"      ‚îÇ
‚îÇ    version: 1.0.0                   ‚îÇ
‚îÇ    ---                              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 2. Markdown Content (Instructions)  ‚îÇ ‚Üê Prompt pour Claude
‚îÇ                                     ‚îÇ
‚îÇ    Purpose explanation              ‚îÇ
‚îÇ    Detailed instructions            ‚îÇ
‚îÇ    Examples and guidelines          ‚îÇ
‚îÇ    Step-by-step procedures          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Frontmatter

Le frontmatter contient les m√©tadonn√©es qui contr√¥lent comment Claude d√©couvre et utilise le skill. Par exemple, voici le frontmatter de `skill-creator` :

```
---
name: skill-creator
description: Guide for creating effective skills. This skill should be used when users want to create a new skill (or update an existing skill) that extends Claude's capabilities with specialized knowledge, workflows, or tool integrations.
license: Complete terms in LICENSE.txt
---
```

Parcourons les champs du frontmatter un par un.

![Claude Skills Frontmatter](https://leehanchung.github.io/assets/img/2025-10-26/04-claude-skill-frontmatter.png)

#### `name` (Requis)

√âvident. Nom du `skill`. Le `name` d'un `skill` est utilis√© comme `command` dans l'`Outil Skill`.

> Le `name` d'un `skill` est utilis√© comme `command` dans l'`Outil Skill`.

#### `description` (Requis)

Le champ `description` fournit un bref r√©sum√© de ce que fait le skill. C'est le signal principal que Claude utilise pour d√©terminer quand invoquer un skill. Dans l'exemple ci-dessus, la description indique explicitement "Ce skill devrait √™tre utilis√© lorsque les utilisateurs veulent cr√©er un nouveau skill" - ce type de langage clair et orient√© action aide Claude √† faire correspondre l'intention de l'utilisateur avec les capacit√©s du skill.

Le syst√®me ajoute automatiquement des informations sur la source √† la description (par exemple, `"(plugin:skills)"`), ce qui aide √† distinguer entre les skills de diff√©rentes sources lorsque plusieurs skills sont charg√©s.

#### `when_to_use` (Non document√© - Probablement obsol√®te ou fonctionnalit√© future)

> **‚ö†Ô∏è Note importante :** Le champ `when_to_use` appara√Æt largement dans la base de code mais n'est **pas document√© dans aucune documentation officielle d'Anthropic**. Ce champ peut √™tre :
>
> *   Une fonctionnalit√© obsol√®te en cours de suppression progressive
> *   Une fonctionnalit√© interne/exp√©rimentale pas encore officiellement support√©e
> *   Une fonctionnalit√© planifi√©e qui n'a pas encore √©t√© publi√©e
>
> **Recommandation :** Comptez sur un champ `description` d√©taill√© √† la place. √âvitez d'utiliser `when_to_use` dans les skills de production jusqu'√† ce qu'il apparaisse dans la documentation officielle.

Bien que non document√©, voici comment `when_to_use` fonctionne actuellement dans la base de code :

```
function formatSkill(skill) {
  let description = skill.whenToUse
    ? `${skill.description} - ${skill.whenToUse}`
    : skill.description;

  return `"${skill.name}": ${description}`;
}
```

Lorsqu'il est pr√©sent, `when_to_use` est ajout√© √† la description avec un s√©parateur tiret. Par exemple :

```
"skill-creator": Create well-structured, reusable skills... - When user wants to build a custom skill package with scripts, references, or assets
```

Cette cha√Æne combin√©e est ce que Claude voit dans le prompt de l'outil Skill. Cependant, comme ce comportement n'est pas document√©, il pourrait changer ou √™tre supprim√© dans les versions futures. L'approche la plus s√ªre est d'inclure les conseils d'utilisation directement dans le champ `description`, comme montr√© dans l'exemple `skill-creator` ci-dessus.

#### `license` (Optionnel)

√âvident.

#### `allowed-tools` (Optionnel)

Le champ `allowed-tools` d√©finit quels outils le skill peut utiliser sans approbation de l'utilisateur, similaire aux allowed-tools de Claude.

C'est une cha√Æne s√©par√©e par des virgules qui est analys√©e en un tableau de noms d'outils autoris√©s. Vous pouvez utiliser des caract√®res g√©n√©riques pour limiter les permissions, par exemple, `Bash(git:*)` n'autorise que les sous-commandes git, tandis que `Bash(npm:*)` permet toutes les op√©rations npm. Le skill skill-creator utilise `"Read,Write,Bash,Glob,Grep,Edit"` pour lui donner de larges capacit√©s de fichiers et de recherche. Une erreur courante est de lister tous les outils disponibles, ce qui cr√©e un risque de s√©curit√© et va √† l'encontre du mod√®le de s√©curit√©.

> N'incluez que ce dont votre skill a r√©ellement besoin - si vous lisez et √©crivez simplement des fichiers, `"Read,Write"` est suffisant.

```
# ‚úÖ skill-creator autorise plusieurs outils
allowed-tools: "Read,Write,Bash,Glob,Grep,Edit"

# ‚úÖ Commandes git sp√©cifiques uniquement
allowed-tools: "Bash(git status:*),Bash(git diff:*),Bash(git log:*),Read,Grep"

# ‚úÖ Op√©rations de fichiers uniquement
allowed-tools: "Read,Write,Edit,Glob,Grep"

# ‚ùå Surface d'attaque inutile
allowed-tools: "Bash,Read,Write,Edit,Glob,Grep,WebSearch,Task,Agent"

# ‚ùå Surface d'attaque inutile avec toutes les commandes npm
allowed-tools: "Bash(npm:*),Read,Write"
```

#### `model` (Optionnel)

Le champ `model` d√©finit quel mod√®le le skill peut utiliser. Il h√©rite par d√©faut du mod√®le actuel dans la session utilisateur. Pour les t√¢ches complexes comme la revue de code, les skills peuvent demander des mod√®les plus capables comme Claude Opus ou d'autres mod√®les chinois OSS. Si vous savez, vous savez.

```
model: "claude-opus-4-20250514"  # Utiliser un mod√®le sp√©cifique
model: "inherit"                 # Utiliser le mod√®le actuel de la session (par d√©faut)
```

#### `version`, `disable-model-invocation` et `mode` (Optionnel)

Les skills supportent trois champs frontmatter optionnels pour le contr√¥le de version et d'invocation. Le champ `version` (par exemple, version: "1.0.0") est un champ de m√©tadonn√©es pour suivre les versions de skills, analys√© depuis le frontmatter mais principalement utilis√© √† des fins de documentation et de gestion de skills.

Le champ `disable-model-invocation` (bool√©en) emp√™che Claude d'invoquer automatiquement le skill via l'outil `Skill`. Lorsqu'il est d√©fini sur true, le skill est exclu de la liste montr√©e √† Claude et ne peut √™tre invoqu√© manuellement que par les utilisateurs via `/skill-name`, ce qui le rend id√©al pour les op√©rations dangereuses, les commandes de configuration ou les flux de travail interactifs qui n√©cessitent un contr√¥le explicite de l'utilisateur.

Le champ `mode` (bool√©en) cat√©gorise un skill comme une "commande de mode" qui modifie le comportement ou le contexte de Claude. Lorsqu'il est d√©fini sur true, le skill appara√Æt dans une section sp√©ciale "Commandes de mode" en haut de la liste des skills (s√©par√©e des skills utilitaires r√©guliers), ce qui le rend pro√©minent pour les skills comme debug-mode, expert-mode ou review-mode qui √©tablissent des contextes op√©rationnels ou des flux de travail sp√©cifiques.

### Contenu du prompt SKILL.md

Apr√®s le frontmatter vient le contenu markdown - le prompt r√©el que Claude re√ßoit lorsque le `skill` est invoqu√©. C'est ici que vous d√©finissez le comportement, les instructions et les flux de travail du `skill`. La cl√© pour √©crire des prompts de skill efficaces est de les garder concentr√©s et d'utiliser la divulgation progressive : fournir les instructions principales dans SKILL.md, et r√©f√©rencer des fichiers externes pour le contenu d√©taill√©.

Voici une structure de contenu recommand√©e

```
---
# Frontmatter ici
---

# [√ânonc√© d'objectif bref - 1-2 phrases]

## Vue d'ensemble
[Ce que fait ce skill, quand l'utiliser, ce qu'il fournit]

## Pr√©requis
[Outils, fichiers ou contexte requis]

## Instructions

### √âtape 1 : [Premi√®re action]
[Instructions imp√©ratives]
[Exemples si n√©cessaire]

### √âtape 2 : [Action suivante]
[Instructions imp√©ratives]

### √âtape 3 : [Action finale]
[Instructions imp√©ratives]

## Format de sortie
[Comment structurer les r√©sultats]

## Gestion des erreurs
[Que faire lorsque les choses √©chouent]

## Exemples
[Exemples d'utilisation concrets]

## Ressources
[R√©f√©rencer scripts/, references/, assets/ si group√©s]
```

Par exemple, le skill `skill-creator` contient les instructions suivantes qui sp√©cifient chaque √©tape du flux de travail requis pour cr√©er des skills.

```
## Processus de cr√©ation de Skill

### √âtape 1 : Comprendre le Skill avec des exemples concrets
### √âtape 2 : Planifier le contenu du Skill r√©utilisable
### √âtape 3 : Initialiser le Skill
### √âtape 4 : √âditer le Skill
### √âtape 5 : Empaqueter un Skill
```

Lorsque Claude invoque ce skill, il re√ßoit l'int√©gralit√© du prompt comme nouvelles instructions avec le chemin du r√©pertoire de base ajout√©. La variable `{baseDir}` se r√©sout dans le r√©pertoire d'installation du skill, permettant √† Claude de charger des fichiers de r√©f√©rence en utilisant l'outil Read : `Read({baseDir}/scripts/init_skill.py)`. Ce mod√®le garde le prompt principal concis tout en rendant la documentation d√©taill√©e disponible sur demande.

**Meilleures pratiques pour le contenu du prompt :**

*   Rester sous 5 000 mots (environ 800 lignes) pour √©viter de submerger le contexte
*   Utiliser un langage imp√©ratif ("Analyser le code pour...") et non la deuxi√®me personne ("Vous devriez analyser...")
*   R√©f√©rencer des fichiers externes pour un contenu d√©taill√© plut√¥t que de tout int√©grer
*   Utiliser `{baseDir}` pour les chemins, ne jamais coder en dur des chemins absolus comme `/home/user/project/`

```
‚ùå Read /home/user/project/config.json
‚úÖ Read {baseDir}/config.json
```

Lorsque le skill est invoqu√©, Claude n'a acc√®s qu'aux outils sp√©cifi√©s dans `allowed-tools`, et le mod√®le peut √™tre remplac√© s'il est sp√©cifi√© dans le frontmatter. Le chemin du r√©pertoire de base du skill est automatiquement fourni, rendant les ressources group√©es accessibles.

### Regroupement de ressources avec votre Skill

Les `Skills` deviennent puissants lorsque vous regroupez des ressources de support avec SKILL.md. La structure standard utilise trois r√©pertoires, chacun servant un objectif sp√©cifique :

```
my-skill/
‚îú‚îÄ‚îÄ SKILL.md              # Prompt et instructions principales
‚îú‚îÄ‚îÄ scripts/              # Scripts Python/Bash ex√©cutables
‚îú‚îÄ‚îÄ references/           # Documentation charg√©e dans le contexte
‚îî‚îÄ‚îÄ assets/               # Mod√®les et fichiers binaires
```

**Pourquoi regrouper des ressources ?** Garder SKILL.md concis (moins de 5 000 mots) emp√™che de submerger la fen√™tre de contexte de Claude. Les ressources regroup√©es vous permettent de fournir une documentation d√©taill√©e, des scripts d'automatisation et des mod√®les sans gonfler le prompt principal. Claude ne les charge que lorsque n√©cessaire en utilisant la divulgation progressive.

#### Le r√©pertoire `scripts/`

Le r√©pertoire `scripts/` contient du code ex√©cutable que Claude ex√©cute via l'outil Bash - scripts d'automatisation, processeurs de donn√©es, validateurs ou g√©n√©rateurs de code qui effectuent des op√©rations d√©terministes.

Par exemple, le SKILL.md de `skill-creator` r√©f√©rence des scripts comme ceci :

```
Lors de la cr√©ation d'un nouveau skill √† partir de z√©ro, toujours ex√©cuter le script `init_skill.py`. Le script g√©n√®re commod√©ment un nouveau r√©pertoire de skill mod√®le qui inclut automatiquement tout ce qu'un skill n√©cessite, rendant le processus de cr√©ation de skill beaucoup plus efficace et fiable.

Usage :

```scripts/init_skill.py <skill-name> --path <output-directory>```

Le script :
  - Cr√©e le r√©pertoire du skill au chemin sp√©cifi√©
  - G√©n√®re un mod√®le SKILL.md avec le frontmatter appropri√© et des espaces r√©serv√©s TODO
  - Cr√©e des exemples de r√©pertoires de ressources : scripts/, references/ et assets/
  - Ajoute des exemples de fichiers dans chaque r√©pertoire qui peuvent √™tre personnalis√©s ou supprim√©s
```

Lorsque Claude voit cette instruction, il ex√©cute `python {baseDir}/scripts/init_skill.py`. La variable `{baseDir}` se r√©sout automatiquement dans le chemin d'installation du skill, rendant le skill portable sur diff√©rents environnements.

**Utiliser scripts/ pour** des op√©rations multi-√©tapes complexes, des transformations de donn√©es, des interactions API ou toute t√¢che n√©cessitant une logique pr√©cise mieux exprim√©e en code qu'en langage naturel.

#### Le r√©pertoire `references/`

Le r√©pertoire `references/` stocke la documentation que Claude lit dans son contexte lorsqu'elle est r√©f√©renc√©e. C'est du contenu textuel - fichiers markdown, sch√©mas JSON, mod√®les de configuration ou toute documentation dont Claude a besoin pour accomplir la t√¢che.

Par exemple, le SKILL.md de `mcp-creator` r√©f√©rence des r√©f√©rences comme ceci :

```
#### 1.4 √âtudier la documentation du framework

**Charger et lire les fichiers de r√©f√©rence suivants :**

- **Meilleures pratiques MCP :** [üìã Voir les meilleures pratiques](./reference/mcp_best_practices.md) - Directives principales pour tous les serveurs MCP

**Pour les impl√©mentations Python, charger √©galement :**
- **Documentation SDK Python :** Utiliser WebFetch pour charger `https://raw.githubusercontent.com/modelcontextprotocol/python-sdk/main/README.md`
- [üêç Guide d'impl√©mentation Python](./reference/python_mcp_server.md) - Meilleures pratiques et exemples sp√©cifiques √† Python

**Pour les impl√©mentations Node/TypeScript, charger √©galement :**
- **Documentation SDK TypeScript :** Utiliser WebFetch pour charger `https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/main/README.md`
- [‚ö° Guide d'impl√©mentation TypeScript](./reference/node_mcp_server.md) - Meilleures pratiques et exemples sp√©cifiques √† Node/TypeScript
```

Lorsque Claude rencontre ces instructions, il utilise l'outil Read : `Read({baseDir}/references/mcp_best_practices.md)`. Le contenu est charg√© dans le contexte de Claude, fournissant des informations d√©taill√©es sans encombrer SKILL.md.

**Utiliser references/ pour** la documentation d√©taill√©e, les grandes biblioth√®ques de motifs, les listes de contr√¥le, les sch√©mas API ou tout contenu textuel trop verbeux pour SKILL.md mais n√©cessaire pour la t√¢che.

#### Le r√©pertoire `assets/`

Le r√©pertoire `assets/` contient des mod√®les et des fichiers binaires que Claude r√©f√©rence par chemin mais ne charge pas dans le contexte. Consid√©rez cela comme les ressources statiques du skill - mod√®les HTML, fichiers CSS, images, mod√®les de configuration ou polices.

Dans SKILL.md :

```
Utiliser le mod√®le √† {baseDir}/assets/report-template.html comme structure de rapport.
R√©f√©rencer le diagramme d'architecture √† {baseDir}/assets/diagram.png.
```

Claude voit le chemin du fichier mais ne lit pas le contenu. Au lieu de cela, il pourrait copier le mod√®le vers un nouvel emplacement, remplir les espaces r√©serv√©s ou r√©f√©rencer le chemin dans la sortie g√©n√©r√©e.

**Utiliser assets/ pour** des mod√®les HTML/CSS, des images, des fichiers binaires, des mod√®les de configuration ou tout fichier que Claude manipule par chemin plut√¥t que de lire dans le contexte.

La distinction cl√© entre `references/` et `assets/` est que

*   **references/ :** Contenu textuel charg√© dans le contexte de Claude via l'outil Read
*   **assets/ :** Fichiers r√©f√©renc√©s par chemin uniquement, non charg√©s dans le contexte

Cette distinction est importante pour la gestion du contexte. Un fichier markdown de 10 Ko dans `references/` consomme des tokens de contexte lorsqu'il est charg√©. Un mod√®le HTML de 10 Ko dans `assets/` ne le fait pas. Claude sait juste que le chemin existe.

> **Meilleure pratique :** Toujours utiliser `{baseDir}` pour les chemins, ne jamais coder en dur des chemins absolus. Cela rend les skills portables entre les environnements utilisateur, les r√©pertoires de projet et les diff√©rentes installations.

### Mod√®les de Skill courants

Comme pour tout en ing√©nierie, comprendre les mod√®les courants aide √† concevoir des skills efficaces. Voici les mod√®les les plus utiles pour l'int√©gration d'outils et la conception de flux de travail.

#### Mod√®le 1 : Automatisation de script

**Cas d'usage :** Op√©rations complexes n√©cessitant plusieurs commandes ou une logique d√©terministe.

Ce mod√®le d√©l√®gue les t√¢ches de calcul aux scripts Python ou Bash dans le r√©pertoire `scripts/`. Le prompt du skill indique √† Claude d'ex√©cuter le script et de traiter sa sortie.

![Claude Skill Script Automation](https://leehanchung.github.io/assets/img/2025-10-26/09-script-automation.png)

**Exemple SKILL.md :**

```
Ex√©cuter scripts/analyzer.py sur le r√©pertoire cible :

`python {baseDir}/scripts/analyzer.py --path "$USER_PATH" --output report.json`

Analyser le `report.json` g√©n√©r√© et pr√©senter les r√©sultats.
```

**Outils requis :**

```
allowed-tools: "Bash(python {baseDir}/scripts/*:*), Read, Write"
```

#### Mod√®le 2 : Lire - Traiter - √âcrire

**Cas d'usage :** Transformation de fichiers et traitement de donn√©es.

Le mod√®le le plus simple - lire l'entr√©e, la transformer en suivant les instructions, √©crire la sortie. Utile pour les conversions de format, le nettoyage de donn√©es ou la g√©n√©ration de rapports.

![Claude Skill Read Process Write](https://leehanchung.github.io/assets/img/2025-10-26/10-read-process-write.png)

**Exemple SKILL.md :**

```
## Flux de traitement
1. Lire le fichier d'entr√©e en utilisant l'outil Read
2. Analyser le contenu selon le format
3. Transformer les donn√©es en suivant les sp√©cifications
4. √âcrire la sortie en utilisant l'outil Write
5. Rapporter l'ach√®vement avec un r√©sum√©
```

**Outils requis :**

```
allowed-tools: "Read, Write"
```

#### Mod√®le 3 : Rechercher - Analyser - Rapporter

**Cas d'usage :** Analyse de base de code et d√©tection de motifs.

Rechercher la base de code pour des motifs en utilisant Grep, lire les fichiers correspondants pour le contexte, analyser les r√©sultats et g√©n√©rer un rapport structur√©. Ou, rechercher un entrep√¥t de donn√©es d'entreprise pour des donn√©es, analyser les donn√©es r√©cup√©r√©es pour des informations et g√©n√©rer un rapport structur√©.

![Claude Skill Search Analyze Report](https://leehanchung.github.io/assets/img/2025-10-26/06-search-analyze-report.png)

**Exemple SKILL.md :**

```
## Processus d'analyse
1. Utiliser Grep pour trouver les motifs de code pertinents
2. Lire chaque fichier correspondant
3. Analyser pour les vuln√©rabilit√©s
4. G√©n√©rer un rapport structur√©
```

**Outils requis :**

```
allowed-tools: "Grep, Read"
```

#### Mod√®le 4 : Ex√©cution de cha√Æne de commandes

**Cas d'usage :** Op√©rations multi-√©tapes avec d√©pendances.

Ex√©cuter une s√©quence de commandes o√π chaque √©tape d√©pend du succ√®s de la pr√©c√©dente. Courant pour les flux de travail de type CI/CD.

![Claude Skill Command Chain Execution](https://leehanchung.github.io/assets/img/2025-10-26/05-command-chain-execution.png)

**Exemple SKILL.md :**

```
Ex√©cuter le pipeline d'analyse :
npm install && npm run lint && npm test

Rapporter les r√©sultats de chaque √©tape.
```

**Outils requis :**

```
allowed-tools: "Bash(npm install:*), Bash(npm run:*), Read"
```

### Mod√®les avanc√©s

#### Flux de travail multi-√©tapes de type assistant

**Cas d'usage :** Processus complexes n√©cessitant une entr√©e utilisateur √† chaque √©tape.

D√©composer les t√¢ches complexes en √©tapes discr√®tes avec une confirmation utilisateur explicite entre chaque phase. Utile pour les assistants de configuration, les outils de configuration ou les processus guid√©s.

**Exemple SKILL.md :**

```
## Flux de travail

### √âtape 1 : Configuration initiale
1. Demander √† l'utilisateur le type de projet
2. Valider que les pr√©requis existent
3. Cr√©er la configuration de base
Attendre la confirmation de l'utilisateur avant de continuer.

### √âtape 2 : Configuration
1. Pr√©senter les options de configuration
2. Demander √† l'utilisateur de choisir les param√®tres
3. G√©n√©rer le fichier de configuration
Attendre la confirmation de l'utilisateur avant de continuer.

### √âtape 3 : Initialisation
1. Ex√©cuter les scripts d'initialisation
2. V√©rifier que la configuration a r√©ussi
3. Rapporter les r√©sultats
```

#### G√©n√©ration bas√©e sur mod√®le

**Cas d'usage :** Cr√©ation de sorties structur√©es √† partir de mod√®les stock√©s dans `assets/`.

Charger les mod√®les, remplir les espaces r√©serv√©s avec des donn√©es fournies par l'utilisateur ou g√©n√©r√©es, et √©crire le r√©sultat. Courant pour la g√©n√©ration de rapports, la cr√©ation de code passe-partout ou la documentation.

**Exemple SKILL.md :**

```
## Processus de g√©n√©ration
1. Lire le mod√®le depuis {baseDir}/assets/template.html
2. Analyser les exigences de l'utilisateur
3. Remplir les espaces r√©serv√©s du mod√®le :
   -  ‚Üí nom fourni par l'utilisateur
   -  ‚Üí r√©sum√© g√©n√©r√©
   -  ‚Üí date actuelle
4. √âcrire le mod√®le rempli dans le fichier de sortie
5. Rapporter l'ach√®vement
```

#### Raffinement it√©ratif

**Cas d'usage :** Processus n√©cessitant plusieurs passes avec une profondeur croissante.

Effectuer d'abord une analyse large, puis des plong√©es progressivement plus profondes sur les probl√®mes identifi√©s. Utile pour la revue de code, les audits de s√©curit√© ou l'analyse de qualit√©.

**Exemple SKILL.md :**

```
## Analyse it√©rative

### Passe 1 : Balayage large
1. Rechercher dans toute la base de code des motifs
2. Identifier les probl√®mes de haut niveau
3. Cat√©goriser les r√©sultats

### Passe 2 : Analyse approfondie
Pour chaque probl√®me de haut niveau :
1. Lire le contexte complet du fichier
2. Analyser la cause racine
3. D√©terminer la gravit√©

### Passe 3 : Recommandation
Pour chaque r√©sultat :
1. Rechercher les meilleures pratiques
2. G√©n√©rer un correctif sp√©cifique
3. Estimer l'effort

Pr√©senter le rapport final avec tous les r√©sultats et recommandations.
```

#### Agr√©gation de contexte

**Cas d'usage :** Combiner des informations de plusieurs sources pour construire une compr√©hension compl√®te.

Collecter des donn√©es de diff√©rents fichiers et outils, synth√©tiser en une image coh√©rente. Utile pour les r√©sum√©s de projet, l'analyse de d√©pendances ou les √©valuations d'impact.

**Exemple SKILL.md :**

```
## Collecte de contexte
1. Lire le projet README.md pour la vue d'ensemble
2. Analyser package.json pour les d√©pendances
3. Grep la base de code pour des motifs sp√©cifiques
4. V√©rifier l'historique git pour les changements r√©cents
5. Synth√©tiser les r√©sultats en un r√©sum√© coh√©rent
```

## Architecture interne des Agent Skills

Avec la vue d'ensemble et le processus de construction couverts, nous pouvons maintenant examiner comment les skills fonctionnent r√©ellement sous le capot. Le syst√®me de skills fonctionne √† travers une architecture m√©ta-outil o√π un outil nomm√© `Skill` agit comme un conteneur et un r√©partiteur pour tous les skills individuels. Cette conception distingue fondamentalement les skills des outils traditionnels √† la fois dans l'impl√©mentation et l'objectif.

> L'outil `Skill` est un m√©ta-outil qui g√®re tous les skills

## Conception d'objet Skills

Les outils traditionnels comme `Read`, `Bash` ou `Write` ex√©cutent des actions discr√®tes et retournent des r√©sultats imm√©diats. Les skills fonctionnent diff√©remment. Plut√¥t que d'effectuer des actions directement, ils injectent des instructions sp√©cialis√©es dans l'historique de conversation et modifient dynamiquement l'environnement d'ex√©cution de Claude. Cela se produit √† travers deux messages utilisateur - l'un contenant les m√©tadonn√©es visibles aux utilisateurs, l'autre contenant le prompt de skill complet cach√© de l'interface mais envoy√© √† Claude - et en modifiant le contexte de l'agent pour changer les permissions, changer de mod√®le et ajuster les param√®tres de tokens de r√©flexion pendant la dur√©e d'utilisation du skill.

![Claude Skill Execution Flow](https://leehanchung.github.io/assets/img/2025-10-26/08-claude-skill-execution-flow.png)

| Fonctionnalit√© | Outil normal | Outil Skill |
| --- | --- | --- |
| **Essence** | Ex√©cuteur d'action directe | Injection de prompt + modificateur de contexte |
| **R√¥le de message** | assistant ‚Üí tool_use user ‚Üí tool_result | assistant ‚Üí tool_use Skill user ‚Üí tool_result user ‚Üí skill prompt ‚Üê INJECT√â ! |
| **Complexit√©** | Simple (3-4 messages) | Complexe (5-10+ messages) |
| **Contexte** | Statique | Dynamique (modifi√© par tour) |
| **Persistance** | Interactions d'outils uniquement | Interactions d'outils + prompts de skills |
| **Surcharge de tokens** | Minimale (~100 tokens) | Significative (~1 500+ tokens par tour) |
| **Cas d'usage** | T√¢ches simples et directes | Flux de travail complexes et guid√©s |

La complexit√© est substantielle. Les outils normaux g√©n√®rent des √©changes de messages simples - un appel d'outil assistant suivi d'un r√©sultat utilisateur. Les skills injectent plusieurs messages, fonctionnent dans un contexte modifi√© dynamiquement et portent une surcharge de tokens significative pour fournir les instructions sp√©cialis√©es qui guident le comportement de Claude.

Comprendre comment fonctionne le m√©ta-outil `Skill` r√©v√®le la m√©canique de ce syst√®me. Examinons sa structure :

```
Pd = {
  name: "Skill",  // La constante de nom d'outil : $N = "Skill"

  inputSchema: {
    command: string  // Par ex., "pdf", "skill-creator"
  },

  outputSchema: {
    success: boolean,
    commandName: string
  },

  // üîë CHAMP CL√â : Cela g√©n√®re la liste des skills
  prompt: async () => fN2(),

  // Validation et ex√©cution
  validateInput: async (input, context) => { /* 5 codes d'erreur */ },
  checkPermissions: async (input, context) => { /* allow/deny/ask */ },
  call: async *(input, context) => { /* yields messages + context modifier */ }
}
```

Le champ `prompt` distingue l'outil Skill des autres outils comme `Read` ou `Bash`, qui ont des descriptions statiques. Au lieu d'une cha√Æne fixe, l'outil Skill utilise un g√©n√©rateur de prompt dynamique qui construit sa description √† l'ex√©cution en agr√©geant les noms et descriptions de tous les skills disponibles. Cela impl√©mente la **divulgation progressive** - le syst√®me ne charge que les m√©tadonn√©es minimales (noms de skills et descriptions du frontmatter) dans le contexte initial de Claude, fournissant juste assez d'informations pour que le mod√®le d√©cide quel skill correspond √† l'intention de l'utilisateur. Le prompt de skill complet ne se charge qu'apr√®s que Claude ait fait cette s√©lection, emp√™chant le gonflement du contexte tout en maintenant la d√©couvrabilit√©.

```
async function fN2() {
  let A = await atA(),
    {
      modeCommands: B,
      limitedRegularCommands: Q
    } = vN2(A),
    G = [...B, ...Q].map((W) => W.userFacingName()).join(", ");
  l(`Skills and commands included in Skill tool: ${G}`);
  let Z = A.length - B.length,
    Y = nS6(B),
    J = aS6(Q, Z);
  return `Execute a skill within the main conversation

<skills_instructions>
When users ask you to perform tasks, check if any of the available skills below can help complete the task more effectively. Skills provide specialized capabilities and domain knowledge.

How to use skills:
- Invoke skills using this tool with the skill name only (no arguments)
- When you invoke a skill, you will see <command-message>The "{name}" skill is loading</command-message>
- The skill's prompt will expand and provide detailed instructions on how to complete the task
- Examples:
  - \`command: "pdf"\` - invoke the pdf skill
  - \`command: "xlsx"\` - invoke the xlsx skill
  - \`command: "ms-office-suite:pdf"\` - invoke using fully qualified name

Important:
- Only use skills listed in <available_skills> below
- Do not invoke a skill that is already running
- Do not use this tool for built-in CLI commands (like /help, /clear, etc.)
</skills_instructions>

<available_skills>
${Y}${J}
</available_skills>
`;
}
```

Contrairement √† la fa√ßon dont certains outils vivent dans les prompts syst√®me pour certains assistants comme ChatGPT, Claude **les agent skills ne vivent pas dans le prompt syst√®me**. Ils vivent dans le tableau `tools` comme partie de la description de l'outil `Skill`. Les noms des skills individuels sont repr√©sent√©s comme partie du champ `command` du sch√©ma d'entr√©e de l'outil `Skill`. Pour mieux visualiser √† quoi cela ressemble, voici la structure de requ√™te API r√©elle :

```
{
  "model": "claude-sonnet-4-5-20250929",
  "system": "You are Claude Code, Anthropic's official CLI...",  // ‚Üê Prompt syst√®me
  "messages": [
    {"role": "user", "content": "Help me create a new skill"},
    // ... historique de conversation
  ],
  "tools": [  // ‚Üê Tableau d'outils envoy√© √† Claude
    {
      "name": "Skill",  // ‚Üê Le m√©ta-outil
      "description": "Execute a skill...\n\n<skills_instructions>...\n\n<available_skills>\n...",
      "input_schema": {
        "type": "object",
        "properties": {
          "command": {
            "type": "string",
            "description": "The skill name (no arguments)"  // ‚Üê Nom du skill individuel
          }
        }
      }
    },
    {
      "name": "Bash",
      "description": "Execute bash commands...",
      // ...
    },
    {
      "name": "Read",
      // ...
    }
    // ... autres outils
  ]
}
```

La section `<available_skills>` vit dans la description de l'outil Skill et est r√©g√©n√©r√©e pour chaque requ√™te API. Le syst√®me construit dynamiquement cette liste en agr√©geant les skills actuellement charg√©s depuis les configurations utilisateur et projet, les skills fournis par les plugins et tout skill int√©gr√©, soumis √† une limite de budget de tokens de 15 000 caract√®res par d√©faut. Cette contrainte de budget force les auteurs de skills √† √©crire des descriptions concises et garantit que la description de l'outil ne submerge pas la fen√™tre de contexte du mod√®le.

## Conception d'injection de contexte de conversation et d'ex√©cution de Skill

La plupart des API LLM supportent les messages `role: "system"` qui pourraient th√©oriquement porter des prompts syst√®me. En fait, le ChatGPT d'OpenAI porte ses outils par d√©faut dans ses prompts syst√®me, incluant `bio` pour la m√©moire, `automations` pour la planification de t√¢ches, `canmore` pour contr√¥ler le canvas, `img_gen` pour la g√©n√©ration d'images, `file_search`, `python` et `web` pour la recherche Internet. Et √† la fin, les prompts d'outils repr√©sentent environ 90% du nombre de tokens dans son prompt syst√®me. Cela pourrait √™tre utile mais √† peine efficace si nous avons beaucoup d'outils et/ou de skills √† charger dans le contexte.

Cependant, les messages syst√®me ont une s√©mantique diff√©rente qui les rend inadapt√©s aux skills. Les messages syst√®me d√©finissent un contexte global qui persiste dans toute la conversation, affectant tous les tours suivants avec une autorit√© sup√©rieure aux instructions de l'utilisateur.

Les skills ont besoin d'un comportement temporaire et d√©limit√©. Le skill `skill-creator` ne devrait affecter que les t√¢ches li√©es √† la cr√©ation de skills, pas transformer Claude en sp√©cialiste PDF permanent pour le reste de la session. L'utilisation de `role: "user"` avec `isMeta: true` fait appara√Ætre le prompt du skill comme une entr√©e utilisateur pour Claude, le gardant temporaire et localis√© √† l'interaction actuelle. Apr√®s que le skill se termine, la conversation retourne au contexte de conversation normal et au contexte d'ex√©cution sans modifications comportementales r√©siduelles.

Les outils normaux comme `Read`, `Write` ou `Bash` ont des mod√®les de communication simples. Lorsque Claude invoque `Read`, il envoie un chemin de fichier, re√ßoit le contenu du fichier et continue √† travailler. L'utilisateur voit "Claude a utilis√© l'outil Read" dans sa transcription, et c'est une transparence suffisante. L'outil a fait une chose, a retourn√© un r√©sultat, et c'est la fin de l'interaction. Les skills fonctionnent fondamentalement diff√©remment. Au lieu d'ex√©cuter des actions discr√®tes et de retourner des r√©sultats, les skills injectent des ensembles d'instructions complets qui modifient comment Claude raisonne et aborde la t√¢che. Cela cr√©e un d√©fi de conception que les outils normaux ne rencontrent jamais : les utilisateurs ont besoin de transparence sur quels skills sont en cours d'ex√©cution et ce qu'ils font, tandis que Claude a besoin d'instructions d√©taill√©es, potentiellement verbeuses, pour ex√©cuter correctement le skill. Si les utilisateurs voient les prompts de skills complets dans leur transcription de chat, l'interface devient encombr√©e de milliers de mots d'instructions AI internes. Si l'activation du skill est compl√®tement cach√©e, les utilisateurs perdent la visibilit√© sur ce que le syst√®me fait en leur nom. La solution n√©cessite de s√©parer ces deux canaux de communication en messages distincts avec des r√®gles de visibilit√© diff√©rentes.

Le syst√®me de skills utilise un drapeau `isMeta` sur chaque message pour contr√¥ler s'il appara√Æt dans l'interface utilisateur. Lorsque `isMeta: false` (ou lorsque le drapeau est omis et par d√©faut √† false), le message s'affiche dans la transcription de conversation que les utilisateurs voient. Lorsque `isMeta: true`, le message est envoy√© √† l'API Anthropic comme partie du contexte de conversation de Claude mais n'appara√Æt jamais dans l'interface. Ce simple drapeau bool√©en permet une communication sophistiqu√©e √† deux canaux : un flux pour les utilisateurs humains, un autre pour le mod√®le AI. M√©ta-prompting pour les m√©ta-outils !

Lorsqu'un skill s'ex√©cute, le syst√®me injecte deux messages utilisateur s√©par√©s dans l'historique de conversation. Le premier porte les m√©tadonn√©es du skill avec `isMeta: false`, le rendant visible aux utilisateurs comme indicateur de statut. Le second porte le prompt de skill complet avec `isMeta: true`, le cachant de l'interface tout en le rendant disponible √† Claude. Cette division r√©sout le compromis transparence vs clart√© en montrant aux utilisateurs ce qui se passe sans les submerger avec les d√©tails d'impl√©mentation.

Le message de m√©tadonn√©es utilise une structure XML concise que le frontend peut analyser et afficher de mani√®re appropri√©e :

```
let metadata = [
  `<command-message>${statusMessage}</command-message>`,
  `<command-name>${skillName}</command-name>`,
  args ? `<command-args>${args}</command-args>` : null
].filter(Boolean).join('\n');

// Message 1 : PAS de drapeau isMeta ‚Üí par d√©faut √† false ‚Üí VISIBLE
messages.push({
  content: metadata,
  autocheckpoint: checkpointFlag
});
```

Lorsque le skill PDF s'active, par exemple, les utilisateurs voient un indicateur de chargement propre dans leur transcription :

```
<command-message>The "pdf" skill is loading</command-message>
<command-name>pdf</command-name>
<command-args>report.pdf</command-args>
```

Ce message reste intentionnellement minimal - g√©n√©ralement 50 √† 200 caract√®res. Les balises XML permettent au frontend de l'afficher avec un formatage sp√©cial, de valider que les balises `<command-message>` appropri√©es sont pr√©sentes, et de maintenir une piste d'audit des skills qui ont √©t√© ex√©cut√©s pendant la session. Parce que le drapeau `isMeta` par d√©faut est false lorsqu'il est omis, ces m√©tadonn√©es apparaissent automatiquement dans l'interface.

Le message de prompt de skill adopte l'approche oppos√©e. Il charge le contenu complet de `SKILL.md`, l'augmente potentiellement avec un contexte suppl√©mentaire, et d√©finit explicitement `isMeta: true` pour le cacher des utilisateurs :

```
let skillPrompt = await skill.getPromptForCommand(args, context);

// Augmenter avec du contenu prepend/append si n√©cessaire
let fullPrompt = prependContent.length > 0 || appendContent.length > 0
  ? [...prependContent, ...appendContent, ...skillPrompt]
  : skillPrompt;

// Message 2 : isMeta: true explicite ‚Üí CACH√â
messages.push({
  content: fullPrompt,
  isMeta: true  // CACH√â DE L'INTERFACE, ENVOY√â √Ä L'API
});
```

Un prompt de skill typique fait 500 √† 5 000 mots et fournit des conseils complets pour transformer le comportement de Claude. Le prompt du skill PDF pourrait contenir :

```
Vous √™tes un sp√©cialiste du traitement PDF.

Votre t√¢che est d'extraire du texte de documents PDF en utilisant l'outil pdftotext.

## Processus

1. Valider que le fichier PDF existe
2. Ex√©cuter la commande pdftotext pour extraire le texte
3. Lire le fichier de sortie
4. Pr√©senter le texte extrait √† l'utilisateur

## Outils disponibles

Vous avez acc√®s √† :
- Bash(pdftotext:*) - Pour ex√©cuter la commande pdftotext
- Read - Pour lire le texte extrait
- Write - Pour sauvegarder les r√©sultats si n√©cessaire

## Format de sortie

Pr√©senter le texte extrait clairement format√©.

R√©pertoire de base : /path/to/skill
Arguments utilisateur : report.pdf
```

Ce prompt √©tablit le contexte de la t√¢che, d√©crit le flux de travail, sp√©cifie les outils disponibles, d√©finit le format de sortie et fournit des chemins sp√©cifiques √† l'environnement. La structure markdown avec en-t√™tes, listes et blocs de code aide Claude √† analyser et suivre les instructions. Avec `isMeta: true`, ce prompt entier est envoy√© √† l'API mais n'encombre jamais la transcription de l'utilisateur.

Au-del√† des m√©tadonn√©es principales et du prompt de skill, les skills peuvent injecter des messages conditionnels suppl√©mentaires pour les pi√®ces jointes et les permissions :

```
let allMessages = [
  createMessage({ content: metadata, autocheckpoint: flag }),  // 1. M√©tadonn√©es
  createMessage({ content: skillPrompt, isMeta: true }),       // 2. Prompt de skill
  ...attachmentMessages,                                       // 3. Pi√®ces jointes (conditionnel)
  ...(allowedTools.length || skill.model ? [
    createPermissionsMessage({                                 // 4. Permissions (conditionnel)
      type: "command_permissions",
      allowedTools: allowedTools,
      model: skill.useSmallFastModel ? getFastModel() : skill.model
    })
  ] : [])
];
```

Les messages de pi√®ces jointes peuvent porter des informations de diagnostic, des r√©f√©rences de fichiers ou un contexte suppl√©mentaire qui compl√®te le prompt du skill. Les messages de permissions n'apparaissent que lorsque le skill sp√©cifie `allowed-tools` dans son frontmatter ou demande un remplacement de mod√®le, fournissant des m√©tadonn√©es qui modifient l'environnement d'ex√©cution √† l'ex√©cution. Cette composition modulaire permet √† chaque message d'avoir un objectif sp√©cifique et d'√™tre inclus ou exclu en fonction de la configuration du skill, √©tendant le mod√®le de base √† deux messages pour g√©rer des sc√©narios plus complexes tout en maintenant le m√™me contr√¥le de visibilit√© via les drapeaux `isMeta`.

### Pourquoi deux messages au lieu d'un ?

Une conception √† message unique forcerait un choix impossible. D√©finir `isMeta: false` rendrait le message entier visible, d√©versant des milliers de mots d'instructions AI dans la transcription de chat de l'utilisateur. Les utilisateurs verraient quelque chose comme :

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ The "pdf" skill is loading                  ‚îÇ
‚îÇ                                             ‚îÇ
‚îÇ You are a PDF processing specialist.        ‚îÇ
‚îÇ                                             ‚îÇ
‚îÇ Your task is to extract text from PDF       ‚îÇ
‚îÇ documents using the pdftotext tool.         ‚îÇ
‚îÇ                                             ‚îÇ
‚îÇ ## Process                                  ‚îÇ
‚îÇ                                             ‚îÇ
‚îÇ 1. Validate the PDF file exists             ‚îÇ
‚îÇ 2. Run pdftotext command to extract text    ‚îÇ
‚îÇ 3. Read the output file                     ‚îÇ
‚îÇ ... [500 more lines] ...                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

L'interface devient inutilisable, remplie de d√©tails d'impl√©mentation internes destin√©s √† Claude, pas aux humains. Alternativement, d√©finir `isMeta: true` cacherait tout, ne fournissant aucune transparence sur quel skill s'est activ√© ou quels arguments il a re√ßus. Les utilisateurs n'auraient aucune visibilit√© sur ce que le syst√®me fait en leur nom.

La division en deux messages r√©sout cela en donnant √† chaque message une valeur `isMeta` diff√©rente. Le message 1 avec `isMeta: false` fournit une transparence orient√©e utilisateur. Le message 2 avec `isMeta: true` fournit √† Claude des instructions d√©taill√©es. Ce contr√¥le granulaire permet la transparence sans surcharge d'informations.

Les messages servent √©galement des publics et des objectifs fondamentalement diff√©rents :

| Aspect | Message de m√©tadonn√©es | Message de prompt de skill |
| --- | --- | --- |
| **Public** | Utilisateur humain | Claude (AI) |
| **Objectif** | Statut/transparence | Instructions/conseils |
| **Longueur** | ~50-200 caract√®res | ~500-5 000 mots |
| **Format** | XML structur√© | Markdown en langage naturel |
| **Visibilit√©** | Devrait √™tre visible | Devrait √™tre cach√© |
| **Contenu** | "Que se passe-t-il ?" | "Comment faire ?" |

La base de code traite m√™me ces messages par des chemins diff√©rents. Le message de m√©tadonn√©es est analys√© pour les balises `<command-message>`, valid√© et format√© pour l'affichage de l'interface. Le message de prompt de skill est envoy√© directement √† l'API sans analyse ni validation - c'est du contenu d'instruction brut destin√© uniquement au processus de raisonnement de Claude. Les combiner violerait le principe de responsabilit√© unique en for√ßant un message √† servir deux publics distincts √† travers deux pipelines de traitement diff√©rents.

## √âtude de cas : Cycle de vie d'ex√©cution

Maintenant que l'architecture interne des Agent Skills est couverte, parcourons ce qui se passe lorsqu'un utilisateur dit "Extraire le texte de report.pdf" en examinant le flux d'ex√©cution complet en utilisant un skill `pdf` hypoth√©tique comme √©tude de cas.

![Claude Skill Execution Flow](https://leehanchung.github.io/assets/img/2025-10-26/07-claude-skill-sequence-diagram.png)

### Phase 1 : D√©couverte et chargement (D√©marrage)

Lorsque Claude Code d√©marre, il scanne les skills :

```
async function getAllCommands() {
  // Charger depuis toutes les sources en parall√®le
  let [userCommands, skillsAndPlugins, pluginCommands, builtins] =
    await Promise.all([
      loadUserCommands(),      // ~/.claude/commands/
      loadSkills(),            // .claude/skills/ + plugins
      loadPluginCommands(),    // Commandes d√©finies par les plugins
      getBuiltinCommands()     // Commandes cod√©es en dur
    ]);

  return [...userCommands, ...skillsAndPlugins, ...pluginCommands, ...builtins]
    .filter(cmd => cmd.isEnabled());
}

// Chargement de skill sp√©cifique
async function loadPluginSkills(plugin) {
  // V√©rifier si le plugin a des skills
  if (!plugin.skillsPath) return [];

  // Deux mod√®les support√©s :
  // 1. SKILL.md racine dans skillsPath
  // 2. Sous-r√©pertoires avec SKILL.md

  const skillFiles = findSkillMdFiles(plugin.skillsPath);
  const skills = [];

  for (const file of skillFiles) {
    const content = readFile(file);
    const { frontmatter, markdown } = parseFrontmatter(content);

    skills.push({
      type: "prompt",
      name: `${plugin.name}:${getSkillName(file)}`,
      description: `${frontmatter.description} (plugin:${plugin.name})`,
      whenToUse: frontmatter.when_to_use,  // ‚Üê Note : underscores !
      allowedTools: parseTools(frontmatter['allowed-tools']),
      model: frontmatter.model === "inherit" ? undefined : frontmatter.model,
      isSkill: true,
      promptContent: markdown,
      // ... autres champs
    });
  }

  return skills;
}
```

Pour le skill pdf, cela produit :

```
{
  type: "prompt",
  name: "pdf",
  description: "Extract text from PDF documents (plugin:document-tools)",
  whenToUse: "When user wants to extract or process text from PDF files",
  allowedTools: ["Bash(pdftotext:*)", "Read", "Write"],
  model: undefined,  // Utilise le mod√®le de session
  isSkill: true,
  disableModelInvocation: false,
  promptContent: "You are a PDF processing specialist...",
  // ... autres champs
}
```

### Phase 2 : Tour 1 - Requ√™te utilisateur et s√©lection de Skill

L'utilisateur envoie une requ√™te : "Extraire le texte de report.pdf". Claude re√ßoit ce message avec l'outil `Skill` dans son tableau d'outils. Avant que Claude puisse d√©cider d'invoquer le skill pdf, le syst√®me doit pr√©senter les skills disponibles dans la description de l'outil Skill.

#### Filtrage et pr√©sentation de Skill

Tous les skills charg√©s n'apparaissent pas dans l'outil Skill. Un skill DOIT avoir soit `description` SOIT `when_to_use` dans le frontmatter, sinon il est filtr√©. Crit√®res de filtrage :

```
async function getSkillsForSkillTool() {
  const allCommands = await getAllCommands();

  return allCommands.filter(cmd =>
    cmd.type === "prompt" &&
    cmd.isSkill === true &&
    !cmd.disableModelInvocation &&
    (cmd.source !== "builtin" || cmd.isModeCommand === true) &&
    (cmd.hasUserSpecifiedDescription || cmd.whenToUse)  // ‚Üê Doit en avoir un !
  );
}
```

#### Formatage de Skill

Chaque skill est format√© pour la section `<available_skills>`. Par exemple, notre skill `pdf` hypoth√©tique pourrait √™tre format√© en

`"pdf": Extract text from PDF documents - When user wants to extract or process text from PDF files`

```
function formatSkill(skill) {
  let name = skill.name;
  let description = skill.whenToUse
    ? `${skill.description} - ${skill.whenToUse}`
    : skill.description;

  return `"${name}": ${description}`;
}
```

#### Processus de d√©cision de Claude

Maintenant, lorsque l'utilisateur demande : "Extraire le texte de report.pdf". Claude re√ßoit la requ√™te API avec l'outil `Skill`, lit les `<available_skills>`, et raisonne (hypoth√©tiquement, car nous ne voyons pas les traces de raisonnement) :

```
Raisonnement interne :
- L'utilisateur veut "extraire le texte de report.pdf"
- C'est une t√¢che de traitement PDF
- En regardant les skills disponibles...
- "pdf" : Extraire le texte de documents PDF - Lorsque l'utilisateur veut extraire ou traiter le texte de fichiers PDF
- √áa correspond ! L'utilisateur veut extraire du texte d'un PDF
- D√©cision : Invoquer l'outil Skill avec command="pdf"
```

Notez qu'il n'y a pas de correspondance algorithmique ici. Pas de correspondance lexicale. Pas de correspondance s√©mantique. Pas de recherches. C'est du raisonnement LLM pur pour ses d√©cisions bas√©es sur la description du skill. Une fois fait, Claude retourne une utilisation d'outil :

```
{
  "type": "tool_use",
  "id": "toolu_123abc",
  "name": "Skill",
  "input": {
    "command": "pdf"
  }
}
```

### Phase 3 : Ex√©cution de l'outil Skill

L'outil Skill s'ex√©cute maintenant. Cela correspond √† la bo√Æte jaune "SKILL TOOL EXECUTION" dans le diagramme de s√©quence, qui effectue la validation, les v√©rifications de permissions, le chargement de fichiers et la modification de contexte avant de produire le r√©sultat.

#### √âtape 1 : Validation

```
async validateInput({ command }, context) {
  let skillName = command.trim().replace(/^\//, "");

  // Erreur 1 : Vide
  if (!skillName) return { result: false, errorCode: 1 };

  // Erreur 2 : Skill inconnu
  const allSkills = await getAllCommands();
  if (!skillExists(skillName, allSkills)) {
    return { result: false, errorCode: 2 };
  }

  // Erreur 3 : Impossible de charger
  const skill = getSkill(skillName, allSkills);
  if (!skill) return { result: false, errorCode: 3 };

  // Erreur 4 : Invocation de mod√®le d√©sactiv√©e
  if (skill.disableModelInvocation) {
    return { result: false, errorCode: 4 };
  }

  // Erreur 5 : Pas bas√© sur prompt
  if (skill.type !== "prompt") {
    return { result: false, errorCode: 5 };
  }

  return { result: true };
}
```

Le skill pdf passe toutes les v√©rifications de validation ‚úì

#### √âtape 2 : V√©rification des permissions

```
async checkPermissions({ command }, context) {
  const skillName = command.trim().replace(/^\//, "");
  const permContext = (await context.getAppState()).toolPermissionContext;

  // V√©rifier les r√®gles de refus
  for (const [pattern, rule] of getDenyRules(permContext)) {
    if (matches(skillName, pattern)) {
      return { behavior: "deny", message: "Blocked by permission rules" };
    }
  }

  // V√©rifier les r√®gles d'autorisation
  for (const [pattern, rule] of getAllowRules(permContext)) {
    if (matches(skillName, pattern)) {
      return { behavior: "allow" };
    }
  }

  // Par d√©faut : demander √† l'utilisateur
  return { behavior: "ask", message: `Execute skill: ${skillName}` };
}
```

En supposant qu'il n'y a pas de r√®gles, l'utilisateur est invit√© : "Ex√©cuter le skill : pdf ?"

 L'utilisateur approuve ‚úì

#### √âtape 3 : Charger le fichier de Skill et g√©n√©rer la modification du contexte d'ex√©cution

Avec la validation et les permissions approuv√©es, l'outil Skill charge le fichier de skill et pr√©pare la modification du contexte d'ex√©cution :

```
async *call({ command }, context) {
  const skillName = command.trim().replace(/^\//, "");
  const allSkills = await getAllCommands();
  const skill = getSkill(skillName, allSkills);

  // Charger le prompt du skill
  const promptContent = await skill.getPromptForCommand("", context);

  // G√©n√©rer les balises de m√©tadonn√©es
  const metadata = [
    `<command-message>The "${skill.userFacingName()}" skill is loading</command-message>`,
    `<command-name>${skill.userFacingName()}</command-name>`
  ].join('\n');

  // Cr√©er les messages
  const messages = [
    { type: "user", content: metadata },  // Visible √† l'utilisateur
    { type: "user", content: promptContent, isMeta: true },  // Cach√© de l'utilisateur, visible √† Claude
    // ... pi√®ces jointes, permissions
  ];

  // Extraire la configuration
  const allowedTools = skill.allowedTools || [];
  const modelOverride = skill.model;

  // Produire le r√©sultat avec le modificateur de contexte d'ex√©cution
  yield {
    type: "result",
    data: { success: true, commandName: skillName },
    newMessages: messages,

    // üîë Fonction de modification du contexte d'ex√©cution
    contextModifier(context) {
      let modified = context;

      // Injecter les outils autoris√©s
      if (allowedTools.length > 0) {
        modified = {
          ...modified,
          async getAppState() {
            const state = await context.getAppState();
            return {
              ...state,
              toolPermissionContext: {
                ...state.toolPermissionContext,
                alwaysAllowRules: {
                  ...state.toolPermissionContext.alwaysAllowRules,
                  command: [
                    ...state.toolPermissionContext.alwaysAllowRules.command || [],
                    ...allowedTools  // ‚Üê Pr√©-approuver ces outils
                  ]
                }
              }
            };
          }
        };
      }

      // Remplacer le mod√®le
      if (modelOverride) {
        modified = {
          ...modified,
          options: {
            ...modified.options,
            mainLoopModel: modelOverride
          }
        };
      }

      return modified;
    }
  };
}
```

L'outil Skill produit son r√©sultat contenant `newMessages` (m√©tadonn√©es + prompt de skill + permissions pour l'injection de contexte de conversation) et `contextModifier` (permissions d'outils + remplacement de mod√®le pour la modification du contexte d'ex√©cution). Cela compl√®te la bo√Æte jaune "SKILL TOOL EXECUTION" du diagramme de s√©quence.

### Phase 4 : Envoi √† l'API (Fin du tour 1)

Le syst√®me construit le tableau de messages complet √† envoyer √† l'API Anthropic. Cela inclut tous les messages de la conversation plus les messages de skill nouvellement inject√©s :

```
// Tableau de messages complet envoy√© √† l'API pour le tour 1
{
  model: "claude-sonnet-4-5-20250929",
  messages: [
    {
      role: "user",
      content: "Extract text from report.pdf"
    },
    {
      role: "assistant",
      content: [
        {
          type: "tool_use",
          id: "toolu_123abc",
          name: "Skill",
          input: { command: "pdf" }
        }
      ]
    },
    {
      role: "user",
      content: "<command-message>The \"pdf\" skill is loading</command-message>\n<command-name>pdf</command-name>"
      // isMeta: false (par d√©faut) - VISIBLE √† l'utilisateur dans l'interface
    },
    {
      role: "user",
      content: "You are a PDF processing specialist...\n\n## Process\n1. Validate PDF exists\n2. Run pdftotext...",
      isMeta: true  // CACH√â de l'interface, envoy√© √† l'API
    },
    {
      role: "user",
      content: {
        type: "command_permissions",
        allowedTools: ["Bash(pdftotext:*)", "Read", "Write"],
        model: undefined
      }
    }
  ]
}
```

![Turn 1 Completion](https://leehanchung.github.io/assets/img/2025-10-26/11-turn-1-completion.png)

Ce qui pr√©c√®de montre ce que nous avons fait jusqu'√† pr√©sent. Le modificateur de contexte d'ex√©cution est appliqu√©, pr√©-approuvant `Bash(pdftotext:*)`, `Read` et `Write` pour les appels d'outils suivants. La requ√™te est envoy√©e √† l'API Anthropic. Cela conclut l'ex√©cution du skill. Si c'√©tait un outil normal, nous aurions fini. Cependant, les skills sont diff√©rents. L'agent skill n'a inject√© que le contexte de conversation et les contextes d'ex√©cution. Cela signifie que nous devons encore invoquer l'agent Claude avec tous ces contextes inject√©s pour compl√©ter la requ√™te de l'utilisateur !

### Phase 5 : Ex√©cution de l'outil Bash (Utilisation d'outil avec contexte de Skill !)

Claude re√ßoit la r√©ponse API avec le contexte de conversation inject√©. Le prompt du skill a transform√© le comportement de Claude, lui fournissant :

*   Des instructions sp√©cialis√©es de traitement PDF (contexte de conversation)
*   Un acc√®s pr√©-approuv√© aux outils `Bash(pdftotext:*)`, `Read` et `Write` (contexte d'ex√©cution)
*   Un flux de travail clair √† suivre (contexte de conversation)

Claude traite le contexte et suit le flux de travail du skill pdf :

```
Je vais extraire le texte de report.pdf. Laissez-moi traiter le fichier.

[En suivant les instructions du skill pdf]
1. Valider que report.pdf existe
2. Ex√©cuter la commande pdftotext pour extraire le texte
3. Lire le fichier de sortie
4. Vous pr√©senter le texte extrait
```

Claude utilise l'outil Bash (pr√©-approuv√©, pas de prompt utilisateur requis) :

```
{
  "type": "tool_use",
  "id": "toolu_456def",
  "name": "Bash",
  "input": {
    "command": "pdftotext report.pdf output.txt",
    "description": "Extract text from PDF using pdftotext"
  }
}
```

L'outil Bash s'ex√©cute avec succ√®s, retournant le r√©sultat. Claude lit ensuite le fichier de sortie en utilisant l'outil Read et pr√©sente le texte extrait √† l'utilisateur. Le skill a guid√© avec succ√®s Claude √† travers le flux de travail sp√©cialis√© d'extraction PDF en injectant des instructions dans le contexte de conversation et en modifiant le contexte d'ex√©cution pour les permissions d'outils.

## Conclusion : R√©capitulatif du mod√®le mental

Les Skills dans Claude Code sont des **modificateurs de contexte de conversation et d'ex√©cution bas√©s sur des prompts** qui fonctionnent √† travers une architecture m√©ta-outil :

**Points cl√©s :**

1.   Les Skills sont des **mod√®les de prompt** dans les fichiers `SKILL.md`, pas du code ex√©cutable
2.   L'**outil Skill** (S majuscule) est un m√©ta-outil dans le tableau `tools` qui g√®re les skills individuels, pas dans le prompt syst√®me
3.   Les Skills **modifient le contexte de conversation** en injectant des prompts d'instruction (via des messages `isMeta: true`)
4.   Les Skills **modifient le contexte d'ex√©cution** en changeant les permissions d'outils et la s√©lection de mod√®le
5.   La s√©lection se fait via le **raisonnement LLM**, pas la correspondance algorithmique
6.   Les permissions d'outils sont **d√©limit√©es √† l'ex√©cution du skill** via la modification du contexte d'ex√©cution
7.   Les Skills injectent deux messages utilisateur par invocation - un pour les m√©tadonn√©es visibles par l'utilisateur, un pour les instructions cach√©es envoy√©es √† l'API

**La conception √©l√©gante :** En traitant les connaissances sp√©cialis√©es comme _des prompts qui modifient le contexte de conversation_ et _des permissions qui modifient le contexte d'ex√©cution_ plut√¥t que _du code qui s'ex√©cute_, Claude Code atteint une flexibilit√©, une s√©curit√© et une composabilit√© qui seraient difficiles avec les appels de fonctions traditionnels.

## R√©f√©rences

*   [Introducing Agent Skills](https://www.anthropic.com/news/introducing-agent-skills)
*   [Equipping Agents for the Real World with Agent Skills](https://www.anthropic.com/news/agent-skills)
*   [Claude Code Documentation](https://docs.claude.com/claude-code)
*   [Anthropic API Reference](https://docs.anthropic.com/api)
*   [Official Documented Frontmatter Fields](https://docs.claude.com/claude-code/skills)
*   [Internal Comms Skill](https://github.com/anthropics/skills)
*   [Skill Creator Skill](https://github.com/anthropics/skills)
*   ChatGPT 5 System Prompt (divulgu√©, non officiel)

---

## ‚ÑπÔ∏è Informations sur la source

**Article original :** [Claude Agent Skills: A First Principles Deep Dive](https://leehanchung.github.io/blogs/2025/10/26/claude-skills-deep-dive/)

- **Source :** Hanchung Lee's Blog
- **Auteur :** Hanchung Lee
- **Publi√© :** 26 octobre 2025
- **Import√© :** 24 novembre 2025
- **Licence :** Copyright ¬© 2025 Hanchung Lee

*Cet article a √©t√© automatiquement import√© et traduit en utilisant Claude AI via le skill fumadocs-article-importer.*
